<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[Java] 접근 제한자</title>
    <link href="/2023/05/24/access-modifier/"/>
    <url>/2023/05/24/access-modifier/</url>
    
    <content type="html"><![CDATA[<h2 id="접근-제한자"><a href="#접근-제한자" class="headerlink" title="접근 제한자"></a>접근 제한자</h2><p>접근 제한자(Access Modifier)는 말 그래도 제한하기 위해 사용한다.<br>여기서 접근이란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 말한다.</p><p>어떤 경우에는 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있다.<br>또한 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 필드나 메소드를 사용하지 못하도록 막아야 하는 경우도 있다.<br>이때 접근 제한자를 사용할 수 있다.</p><h3 id="접근-제한자-종류"><a href="#접근-제한자-종류" class="headerlink" title="접근 제한자 종류"></a>접근 제한자 종류</h3><p><strong><code>Public</code></strong> : 외부 클래스가 자유롭게 사용할 수 있도록 한다.<br><strong><code>Protected</code></strong> : 같은 패키지 또는 자식 클래스에서 사용할 수 있도록 한다.<br><strong><code>Private</code></strong> : 개인적인 것이라 외부에서 사용될 수 없도록 한다.<br><strong><code>default</code></strong> : 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 한다. (위 세 가지 접근 제한자가 적용되지 않을 시)</p><h2 id="클래스-접근-제한"><a href="#클래스-접근-제한" class="headerlink" title="클래스 접근 제한"></a>클래스 접근 제한</h2><p>클래스를 선언할 때 해당 클래스를 같은 패키지에서도 사용할 수 있도록 할 것인지 결정해야 한다.<br>클래스는 다음과 같이 public, default 접근 제한을 가진다.</p><h3 id="default-접근-제한"><a href="#default-접근-제한" class="headerlink" title="default 접근 제한"></a>default 접근 제한</h3><p>클래스를 선언할 때 public을 생략했다면 클래스는 default 접근 제한을 가진다.<br>클래스가 default 접근 제한을 가지면 같은 패키지에서는 아무런 제한 없이 사용할 수 있지만<br>다른 패키지에서는 사용할 수 없도록 제한한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="public-접근-제한"><a href="#public-접근-제한" class="headerlink" title="public 접근 제한"></a>public 접근 제한</h3><p>클래스를 선언할 때 public 접근 제한자를 붙였다면 클래스는 public 접근 제한을 가진다.<br>클래스가 public 접근 제한을 가지면, 같은 패키지 뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다.<br>클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발한다면 반드시 public 접근 제한을 가지도록 해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="생성자의-접근-제한"><a href="#생성자의-접근-제한" class="headerlink" title="생성자의 접근 제한"></a>생성자의 접근 제한</h3><p>객체를 생성하기 위해서는 new 연산자로 생성자를 호출한다. 그러나 생성자를 어디에서나 호출할 수 있는 것은 아니다.<br>생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능 여부가 결정된다.</p><p>생성자는 다음과 같이 <strong><code>public</code></strong> , <strong><code>protected</code></strong> , <strong><code>default</code></strong> , <strong><code>private</code></strong> 접근 제한을 가진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// public 접근 제한</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(...)&#123;...&#125;<br><br><span class="hljs-comment">// protected 접근 제한</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>(...)&#123;...&#125;<br><br><span class="hljs-comment">// default 접근 제한</span><br>ClassName(...)&#123;...&#125;<br><br><span class="hljs-comment">// private 접근 제한</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ClassName</span><span class="hljs-params">(...)</span>&#123;...&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Java] 클래스</title>
    <link href="/2023/05/23/class/"/>
    <url>/2023/05/23/class/</url>
    
    <content type="html"><![CDATA[<h2 id="객체와-클래스"><a href="#객체와-클래스" class="headerlink" title="객체와 클래스"></a>객체와 클래스</h2><p>자바에서는 설계도가 바로 클래스(Class)이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.<br>클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(Instance)라고 한다. 그리고 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.<br>하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.</p><h2 id="객체-지향-프로그래밍-개발의-세-가지-단계"><a href="#객체-지향-프로그래밍-개발의-세-가지-단계" class="headerlink" title="객체 지향 프로그래밍 개발의 세 가지 단계"></a>객체 지향 프로그래밍 개발의 세 가지 단계</h2><h3 id="1단계"><a href="#1단계" class="headerlink" title="1단계"></a>1단계</h3><p>클래스를 설계한다.</p><h3 id="2단계"><a href="#2단계" class="headerlink" title="2단계"></a>2단계</h3><p>설계된 클래스를 가지고 사용할 객체를 생성한다.</p><h3 id="3단계"><a href="#3단계" class="headerlink" title="3단계"></a>3단계</h3><p>생성된 객체를 이용한다.</p><h2 id="클래스-선언"><a href="#클래스-선언" class="headerlink" title="클래스 선언"></a>클래스 선언</h2><h3 id="식별자-작성-규칙"><a href="#식별자-작성-규칙" class="headerlink" title="식별자 작성 규칙"></a>식별자 작성 규칙</h3><ol><li>하나 이상의 문자로 이루어져야 한다. Ex.Car, SportsCar</li><li>첫 글자에는 숫자가 올 수 없다.</li><li><code>$</code>, <code>_</code> 외의 특수 문자는 사용할 수 없다.</li><li>자바 키워드는 사용할 수 없다.</li></ol><p><strong>예시</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs code">Calculator, Car, Member, ChatClient . . .<br></code></pre></td></tr></table></figure><p>클래스 이름을 정했다면 ‘클래스이름.java’로 소스 파일을 생성해야 한다.<br>소스 파일 이름 역시 대소문자를 구분하므로 반드시 클래스 이름과 대소문자가 같도록 해야 한다.<br>소스 파일을 생성하면 소스 파일을 열고 다음과 같이 클래스를 선언해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 클래스이름 &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>여기서 public class 키워드는 클래스를 선언할 때 사용하며, 반드시 소문자로 작성해야 한다.<br>클래스 이름 뒤에는 반드시 중괄호 {}를 붙여주는데, 시작 중괄호 <code>&#123;</code> 는 클래스 선언의 시작을 알려주고,<br>끝 중괄호 <code>&#125;</code>는 클래스 선언의 끝을 알려준다.</p><p>일반적으로 소스 파일당 하나의 클래스를 선언하지만 2개 이상의 클래스 선언도 가능하다.</p><p>2개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다.<br>결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.</p><h2 id="객체-생성과-클래스-변수"><a href="#객체-생성과-클래스-변수" class="headerlink" title="객체 생성과 클래스 변수"></a>객체 생성과 클래스 변수</h2><p>클래스를 선언한 다음, 컴파일을 했다면 객체를 생성할 설계도가 만들어진 셈이다.<br>클래스로부터 객체를 생성하려면 다음과 같이 new 연산자를 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 클래스();<br></code></pre></td></tr></table></figure><p>new는 클래스로부터 객체를 생성시키는 연산자이다.<br>new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.<br>new 연산자로 생성된 객체는 메모리 힙(heap)영역에 생성된다.</p><p>현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이, 객체 지향 프로그램에서도 메모리에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 그래서 new 연산자는 힙 영역에 객체를 생성시킨 후 객체의 번지를 리턴하도록 되어 있다. 이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있다. 다음은 클래스로 선언된 변수에 new 연산자가 리턴한 객체의 번지를 저장하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">클래스 변수;<br>변수 = <span class="hljs-keyword">new</span> 클래스();<br></code></pre></td></tr></table></figure><p>클래스 변수 선언과 객체 생성을 1개의 실행문으로도 작성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">클래스 변수 = <span class="hljs-keyword">new</span> 클래스;<br></code></pre></td></tr></table></figure><p>이렇게 new 연산자로 객체를 생성하고 리턴된 객체의 번지를 변수에 저장하면 변수가 객체를 참조하게 된다.</p><h2 id="클래스의-구성-멤버"><a href="#클래스의-구성-멤버" class="headerlink" title="클래스의 구성 멤버"></a>클래스의 구성 멤버</h2><p>클래스에는 객체가 가져야 할 구성 멤버가 선언된다.<br>구성 맴버에는 필드(field), 생성자(Constructor), 메소드(Method)가 있다.<br>이 구성 맴버들은 생략되거나 복수의 개수로 작성될 수 있다.</p><ul><li>필드: 객체의 데이터가 저장되는 곳</li><li>생성자: 객체 생성 시 초기화 역할을 담당</li><li>메소드: 객체의 동작에 해당하는 실행 블록</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br>    <span class="hljs-comment">// 필드</span><br>    <span class="hljs-type">int</span> fieldName;<br><br>    <span class="hljs-comment">// 생성자</span><br>    ClassName() &#123;...&#125;<br><br>    <span class="hljs-comment">// 메소드</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Java] 객체 개념</title>
    <link href="/2023/05/23/object/"/>
    <url>/2023/05/23/object/</url>
    
    <content type="html"><![CDATA[<h2 id="객체란"><a href="#객체란" class="headerlink" title="객체란,"></a>객체란,</h2><p>객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별 가능한 것을 말한다.<br>객체는 속성과 동작으로 구성되어 있다. 자바는 속성과 동작을 각각 필드(field)와 메소드(method)라고 부른다.</p><h2 id="객체의-상호작용"><a href="#객체의-상호작용" class="headerlink" title="객체의 상호작용"></a>객체의 상호작용</h2><p>객체의 상호작용은 객체 간의 메소드 호출을 의미하며 매개값과 리턴값을 통해서 데이터를 주고 받는다.</p><h2 id="객체-간의-관계"><a href="#객체-간의-관계" class="headerlink" title="객체 간의 관계"></a>객체 간의 관계</h2><p>객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.<br>이 관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다.</p><h3 id="집합-관계"><a href="#집합-관계" class="headerlink" title="집합 관계"></a>집합 관계</h3><p>객체는 하나는 부품이고 하나는 완성품에 해당한다.<br>Ex. 자동차는 엔진, 타이어, 핸들 등으로 구성 -&gt; 자동차와 부품들은 집합 관계이다.</p><h3 id="사용-관계"><a href="#사용-관계" class="headerlink" title="사용 관계"></a>사용 관계</h3><p>객체 간의 상호작용을 말한다.<br>객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.<br>Ex. 사람은 자동차를 사용하므로 사람과 자동차 -&gt; 사용관계<br>Ex. 사람은 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출</p><h3 id="상속-관계"><a href="#상속-관계" class="headerlink" title="상속 관계"></a>상속 관계</h3><p>상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계를 말한다.<br>일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다.<br>Ex. 자동차는 기계의 한 종류이다 -&gt; 기계(상위)와 자동차(하위)는 상속 관계에 있다고 볼 수 있다.</p><h2 id="객체-지향-프로그래밍이란"><a href="#객체-지향-프로그래밍이란" class="headerlink" title="객체 지향 프로그래밍이란,"></a>객체 지향 프로그래밍이란,</h2><p>만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 방법이다.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Terraform</title>
    <link href="/2023/03/08/Terraform/"/>
    <url>/2023/03/08/Terraform/</url>
    
    <content type="html"><![CDATA[<h2 id="1-테라폼의-개요"><a href="#1-테라폼의-개요" class="headerlink" title="1. 테라폼의 개요"></a>1. 테라폼의 개요</h2><p><strong>테라폼(Terraform)</strong> 은 Infrastructure 자동화 도구로서, 클라우드 서비스 및 온프레미스 환경에서 Infrastructure를 코드로 정의하고 프로비저닝하는 데 사용됩니다.</p><tr>Infrastructure 코드(Infrastructure as Code, IaC) 개념을 바탕으로 동작하며, 코드 버전 관리 및 협업, Infrastructure 변경사항 추적 등의 장점을 제공합니다. 다양한 클라우드 서비스(예: AWS, Azure, GCP 등) 및 온프레미스 환경에서 동작하며, 클라우드 서비스별로 제공하는 리소스(예: EC2 인스턴스, S3 버킷 등)를 코드로 정의하여 프로비저닝할 수 있습니다.<h2 id="2-테라폼-설치-및-설정-MacOs"><a href="#2-테라폼-설치-및-설정-MacOs" class="headerlink" title="2. 테라폼 설치 및 설정 (MacOs)"></a>2. 테라폼 설치 및 설정 (MacOs)</h2><p>패키지 저장소인 hashicorp tap 설치 후 terraform 설치</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew tap hashicorp/tap<br><br>brew install hashicorp/tap/terraform<br></code></pre></td></tr></table></figure><br/><p>terraform 작동 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform -<span class="hljs-built_in">help</span></span><br>Usage: terraform [global options] &lt;subcommand&gt; [args]<br><br>The available commands for execution are listed below.<br>The primary workflow commands are given first, followed by<br>less common or more advanced commands.<br><br>Main commands:<br>  init          Prepare your working directory for other commands<br>  validate      Check whether the configuration is valid<br>  plan          Show changes required by the current configuration<br>  apply         Create or update infrastructure<br>  destroy       Destroy previously-created infrastructure<br></code></pre></td></tr></table></figure><h2 id="3-Infrastructure-코드-작성"><a href="#3-Infrastructure-코드-작성" class="headerlink" title="3. Infrastructure 코드 작성"></a>3. Infrastructure 코드 작성</h2><p>해당 코드를 실행시키기 위해서는 Docker가 실행되어 있어야 합니다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">open -a Docker<br></code></pre></td></tr></table></figure><br/><p><code>main.tf</code> 파일 생성</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch main.tf<br><br>vim main.tf<br></code></pre></td></tr></table></figure><br/><p>nginx docker 컨테이너 생성을 위한 코드 작성 후 저장</p><tr/><p><code>image</code>: <strong>nginx:latest</strong><br><code>internal port</code>: <strong>80</strong><br><code>external port</code>: <strong>8000</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tf">terraform &#123;<br>  required_providers &#123;<br>    docker = &#123;<br>      source  = &quot;kreuzwerker/docker&quot;<br>      version = &quot;~&gt; 2.13.0&quot;<br>    &#125;<br>  &#125;<br>&#125;<br><br>provider &quot;docker&quot; &#123;&#125;<br><br>resource &quot;docker_image&quot; &quot;nginx&quot; &#123;<br>  name         = &quot;nginx:latest&quot;<br>  keep_locally = false<br>&#125;<br><br>resource &quot;docker_container&quot; &quot;nginx&quot; &#123;<br>  image = docker_image.nginx.latest<br>  name  = &quot;nginx&quot;<br>  ports &#123;<br>    internal = 80<br>    external = 8000<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-프로비저닝"><a href="#4-프로비저닝" class="headerlink" title="4. 프로비저닝"></a>4. 프로비저닝</h2><p>프로젝트 초기화</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform init</span><br>Initializing the backend...<br><br>...<br><br>Terraform has been successfully initialized!<br></code></pre></td></tr></table></figure><br/><p>NGINX 서버 컨테이너 프로비저닝</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">terraform apply</span><br>Do you want to perform these actions?<br>  Terraform will perform the actions described above.<br>  Only &#x27;yes&#x27; will be accepted to approve.<br><br>  Enter a value: yes<br><br><br>  Apply complete! Resources: 2 added, 0 changed, 0 destroyed.<br></code></pre></td></tr></table></figure><br/><p>컨테이너 실행 여부 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker ps</span><br>CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                  NAMES<br>fd2b2665dc90   114aa6a9f203   &quot;/docker-entrypoint.…&quot;   23 seconds ago   Up 22 seconds   0.0.0.0:8000-&gt;80/tcp   nginx<br></code></pre></td></tr></table></figure><br/><p>웹 페이지 접속 여부 확인<br><img width="562" src="https://user-images.githubusercontent.com/87232411/223623132-bbd56666-2b43-4112-8df6-d466b77b45c9.png"></p><br/><p>컨테이너 종료</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform destroy<br></code></pre></td></tr></table></figure><h2 id="5-테라폼-모듈"><a href="#5-테라폼-모듈" class="headerlink" title="5. 테라폼 모듈"></a>5. 테라폼 모듈</h2><p>테라폼에서 모듈은 리소스, 변수, 출력값 등을 포함하며, 다른 모듈에서 재사용할 수 있습니다.</p><tr><p>이를 통해 코드 중복을 줄이고, 모듈화된 코드를 관리함으로써 코드를 보다 쉽게 유지보수할 수 있습니다.<br>모듈은 모듈 디렉토리 안에 .tf 파일들로 구성됩니다. 테라폼은 이러한 .tf 파일들을 읽어서 모듈을 로드하고 사용합니다. 모듈은 모듈 내부에서 정의된 리소스와 데이터를 관리하며, 다른 모듈과 변수 및 출력값을 공유할 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/87232411/223623817-039bbf9b-3891-4270-b8cd-4ed3645677b9.svg"></p><h2 id="6-테라폼-확장성"><a href="#6-테라폼-확장성" class="headerlink" title="6. 테라폼 확장성"></a>6. 테라폼 확장성</h2><p>테라폼은 클라우드 서비스를 비롯한 다양한 Infrastructure를 코드로 정의하여 관리할 수 있는 확장성이 뛰어난 도구입니다.</p><tr><p>클라우드 서비스(예: AWS, Azure, GCP)를 비롯한 다양한 Infrastructure를 지원하며, 확장성과 유연성을 제공하기 위해 모듈화된 코드 구조와 플러그인 아키텍처를 사용하고 있습니다.<br>또한, 테라폼은 Infrastructure 변경사항을 추적하고 코드 버전 관리를 할 수 있는 기능을 제공하여, 대규모 Infrastructure를 효과적으로 관리할 수 있습니다.<br>이러한 확장성과 유연성을 통해, 테라폼은 다양한 Infrastructure 관리 요구사항에 대응할 수 있으며, 새로운 환경에 대한 대응도 빠르게 이루어질 수 있습니다.</p><br/><br/><br/><p><strong>참고자료: ChatGPT, Terraform 공식 사이트</strong><br><strong>사진 출처: <a href="https://www.scalefactory.com/blog/2021/12/22/terraform-v1.1-the-journey-continues/tf11x.png">https://www.scalefactory.com/blog/2021/12/22/terraform-v1.1-the-journey-continues/tf11x.png</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Terraform</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Terraform</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
